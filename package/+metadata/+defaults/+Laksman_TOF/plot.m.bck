function [exp_md] = plot(exp_md)
% This convenience funciton lists the default plotting metadata, and can be
% read by other experiment-specific metadata files.

d1.labels_to_show     = exp_md.sample.fragment.masses;

% Specify which plot to show:
d1.ifdo.TOF						= false;
d1.ifdo.m2q						= false;
d1.ifdo.m2q_Ci					= false;
d1.ifdo.PEPIPICO				= false;
d1.ifdo.PEPIPICO_m2q			= true;
d1.ifdo.BR_fragment_pair		= false;
d1.ifdo.BR_2D					= false;
d1.ifdo.det_image				= false;
d1.ifdo.TOF_R					= false;
d1.ifdo.p_sum_norm				= false;
d1.ifdo.p2D						= false;
d1.ifdo.dp						= false;
d1.ifdo.KER						= false;
d1.ifdo.KER_sum					= false;
d1.ifdo.angle_p_corr_C2			= true;
d1.ifdo.angle_p_corr_C3			= true;
d1.ifdo.angle_p_corr_C4			= false;
d1.ifdo.KER_angle_p_corr_C2		= false;
d1.ifdo.KER_angle_p_corr_C3		= false;
d1.ifdo.p_norm_angle_corr_C2	= false;
d1.ifdo.p_norm_angle_corr_C3	= false;
d1.ifdo.norm_p_corr_C2			= false;
d1.ifdo.norm_p_corr_C2_ternary	= false;
d1.ifdo.norm_p_corr_C3_ternary	= false;
d1.ifdo.CSD						= false;
d1.ifdo.CSD_cluster_size_sum	= false;
d1.ifdo.CSD_mean_cluster_size_sum= false;
d1.ifdo.fragment_asymmetry		= false;
d1.ifdo.cluster_size_sum_fragment_asymmetry = false;

% Plot styles:
% Plot style and binsize values for TOF:
d1.TOF.binsize        	= 10; % [ns] binsize of the m2q variable. 
d1.TOF.x_range			= [0 200000]; % [ns] x range of the data on x-axis.
d1.TOF.y_range			= 'auto'; % y range of the data on y-axis.
d1.TOF.x_label			= 'TOF [ns]';% label on x-axis.
d1.TOF.y_label			= 'Intensity [a.u.]';% label on y-axis
d1.TOF.color			= [0 0 0]; % Color of the line.
d1.TOF.LineStyle		= '-'; % Style of the line
d1.TOF.grid				= 'minor'; % Which grid to show

% Plot style and binsize values for TOF:
d1.X.binsize        	= 0.1; % [ns] binsize of the m2q variable. 
d1.X.x_range			= [-40 40]; % [ns] x range of the data on x-axis.
d1.X.y_range			= 'auto'; % y range of the data on y-axis.
d1.X.x_label			= 'X [mm]';% label on x-axis.
d1.X.y_label			= 'Intensity [a.u.]';% label on y-axis
d1.X.color				= [0 0 0]; % Color of the line.
d1.X.LineStyle			= '-'; % Style of the line
d1.X.grid				= 'minor'; % Which grid to show

% Plot style and binsize values for TOF:
d1.Y.binsize        	= 0.1; % [ns] binsize of the m2q variable. 
d1.Y.x_range			= [-40 40]; % [ns] x range of the data on x-axis.
d1.Y.y_range			= 'auto'; % y range of the data on y-axis.
d1.Y.x_label			= 'Y [mm]';% label on x-axis.
d1.Y.y_label			= 'Intensity [a.u.]';% label on y-axis
d1.Y.color				= [0 0 0]; % Color of the line.
d1.Y.LineStyle			= '-'; % Style of the line
d1.Y.grid				= 'minor'; % Which grid to show

% Plot style and binsize values for m2q:
d1.m2q.binsize         	= 0.1  ; %[Da] binsize of the m2q variable.
d1.m2q.x_range			= [0 150];%1.2*max(exp_md.conv.det1.m2q_labels)]; % [Da] x range of the data on x-axis.
d1.m2q.x_tick				= exp_md.conv.det1.m2q_labels; % [Da] ticks along x-axis.
d1.m2q.y_range			= 'auto'; % [arb.u] y range of the data on y-axis.
d1.m2q.x_label			= 'm/q [Da]'; % label on x-axis.
d1.m2q.y_label			= 'Intensity [Counts]'; % label on y-axis
d1.m2q.Intensity_type		= 'Normal'; %Show normalized intensity.
d1.m2q.color				= [0 0 0]; % Color of the line.
d1.m2q.LineStyle			= '-';  % Style of the line
d1.m2q.grid				= 'on'; % Which grid to show
d1.m2q.XTickLabelRotation = 70; % [deg] rotation of the XTicks.
d1.m2q.FontSize			= 12; % [mm] Fontsize of the axes, labels, legends
d1.m2q.cond				= exp_md.cond.label;
% d1.m2q.cond				= exp_md.cond.monomer;

% Plot style and binsize values for m2q labels:
d1.m2q_l				= d1.m2q;

% Plot style and binsize values for mass labels:
d1.m2q_l				= d1.m2q;

% Plot style and binsize values for m2q for different C_nrs:
d1.m2q_Ci				= d1.m2q;
d1.m2q_Ci.C_nr			= 3;
d1.m2q_Ci.cond			= exp_md.cond.angle_p_corr_C3;

% Plot style for PEPIPICO 2D plot:
d1.PEPIPICO.binsize       = [10 10]; %[ns] binsize of the m2q variable. 
d1.PEPIPICO.x_range		= [5000 10000]; % [Da] x range of the data on x-axis.
d1.PEPIPICO.y_range		= [5000 10000]; % [Da] y range of the data on y-axis.
d1.PEPIPICO.z_range		= 'auto'; % [Da] z range of the data on z-axis.
d1.PEPIPICO.x_label		= 'TOF [ns]'; % label on x-axis.
d1.PEPIPICO.y_label		= 'TOF [ns]'; % label on y-axis.
d1.PEPIPICO.colormap		= 'custom'; % type of colormap
d1.PEPIPICO.colormap_r	= [1 1];
d1.PEPIPICO.colormap_g	= [1 0];
d1.PEPIPICO.colormap_b	= [1 0];
d1.PEPIPICO.axis          = 'equal'; % axis scaling
d1.PEPIPICO.colorbar		= 'yes'; % Do we want to see a colorbar
d1.PEPIPICO.grid			= 'on'; % Which grid to show

% Plot style for PEPIPICO 2D plot:
d1.PEPIPICO_m2q.binsize		= [1 1]*1e-1; %[Da] binsize of the m2q variable. 
% d1.PEPIPICO_m2q.binsize		= 1*[1 1]*1e-1; %[Da] binsize of the m2q variable. 
d1.PEPIPICO_m2q.x_range		= [12.5 18.5];%[(min(d1.labels_to_show)-1) (max(d1.labels_to_show)+1)]; % [Da] x range of the data on x-axis.
d1.PEPIPICO_m2q.y_range		= [12.5 18.5];%[(min(d1.labels_to_show)-1) (max(d1.labels_to_show)+1)]; % [Da] y range of the data on y-axis.
d1.PEPIPICO_m2q.z_range		= 'auto'; % [Da] z range of the data on z-axis.
d1.PEPIPICO_m2q.ScaleType		= 'log'; % 
d1.PEPIPICO_m2q.x_label		= 'm/q'; % label on x-axis.
d1.PEPIPICO_m2q.y_label		= 'm/q'; % label on y-axis.
d1.PEPIPICO_m2q.x_tick		= exp_md.conv.det1.m2q_labels; % [Da]
d1.PEPIPICO_m2q.axis          = 'equal'; % axis scaling
% d1.PEPIPICO_m2q.colormap		= 'hot';
d1.PEPIPICO_m2q.colormap		= 'custom'; % type of colormap
d1.PEPIPICO_m2q.colormap_r	= [1 1];
d1.PEPIPICO_m2q.colormap_g	= [1 0];
d1.PEPIPICO_m2q.colormap_b	= [1 0];
d1.PEPIPICO_m2q.colorbar		= 'yes'; % Do we want to see a colorbar
d1.PEPIPICO_m2q.grid			= 'on'; % Which grid to show
d1.PEPIPICO_m2q.x_tick		= exp_md.conv.det1.m2q_labels; % Tick on x-axis
d1.PEPIPICO_m2q.y_tick		= exp_md.conv.det1.m2q_labels; % Tick on y-axis
d1.PEPIPICO_m2q.XTickLabelRotation = 90; % [deg] rotation of the XTicks.
d1.PEPIPICO_m2q.FontSize 		= 12; % [mm] Fontsize of the axes, labels, legends
d1.PEPIPICO_m2q.ifdo.reference_line 		= false; % whether to plot the line of complete detection.
% d1.PEPIPICO_m2q.cond			= exp_md.cond.angle_p_corr_C2;
% d1.PEPIPICO_m2q.cond			= exp_md.cond.incompl;
% d1.PEPIPICO_m2q.cond			= exp_md.cond.label;

% Plot style for branching ratio plot:
d1.BR.y_label			= 'Branching ratio [rel.]'; % label on y-axis.
d1.BR.cond				= exp_md.cond.BR;
d1.BR.cond_normalize	= exp_md.cond.BR_normalize;

% Plot style for 2D branching ratio plot:
d1.BR_2D.x_range			= [10 200]; % [Da] x range of the data on x-axis.
d1.BR_2D.y_range			= [10 200]; % [Da] y range of the data on y-axis.
%d1.BR_2D.z_range			= [0 0.5]; % (relative to maximum) color scale intensity.
d1.BR_2D.x_label			= 'First hit, m/q [Da]'; % label on x-axis.
d1.BR_2D.y_label			= 'Second hit, m/q [Da]'; % label on y-axis.
d1.BR_2D.BubbleColor		= [0 0 1]; % color of dots
d1.BR_2D.dotsize			= 200; % size of dots
d1.BR_2D.x_tick			= exp_md.conv.det1.m2q_labels; % Tick on x-axis
d1.BR_2D.y_tick			= exp_md.conv.det1.m2q_labels; % Tick on y-axis

% Plot style for branching ratio plot:
d1.BR_Ci.C_nrs			= [1 2 3 4]; % [Da] x range of the data on x-axis.
d1.BR_Ci.QE_i				= theory.QE.Gilmore.Eff(exp_md.conv.det1.m2q_labels, exp_md.spec.volt.V_created-exp_md.det.det1.Front_Voltage, exp_md.det.det1.Eff.Gilmore.m_0, exp_md.det.det1.Eff.Gilmore.Age_factor); % Quantum efficiency ion detector
d1.BR_Ci.QE_e				= [0.6 0.66 0.68 0.71 0.75]; % Quantum efficiency electron detector, for detecting at least one of one, two, three .... electrons.
d1.BR_Ci.x_label			= 'Ci [-]'; % label on x-axis.
d1.BR_Ci.y_label			= 'Branching ratio [$\#$ events]'; % label on y-axis.
d1.BR_Ci.x_tick			= d1.BR_Ci.C_nrs; % Tick on x-axis
% d1.BR_Ci.cond				= exp_md.cond.cluster;
d1.BR_Ci.cond				= exp_md.cond.label;
% d1.BR_Ci.cond				= exp_md.cond.monomer;

d1.BR_Ci.trend.x_label	= 'Pressure [mbar]';
d1.BR_Ci.trend.y_label	= 'Physical branching ratio [$\%$]'; % label on y-axis.
d1.BR_Ci.trend.y_range	= [0 100];

% Plot style for branching ratio plot:
d1.BR_fragment_pair			= d1.BR_Ci;
d1.BR_fragment_pair.C_nrs		= [1 2 3 4]; % [Da] x range of the data on x-axis.
d1.BR_fragment_pair.QE_i		= theory.QE.Gilmore.Eff(exp_md.conv.det1.m2q_labels, exp_md.spec.volt.V_created-exp_md.det.det1.Front_Voltage, exp_md.det.det1.Eff.Gilmore.m_0, exp_md.det.det1.Eff.Gilmore.Age_factor); % Quantum efficiency ion detector
d1.BR_fragment_pair.QE_e		= [0.6 0.66 0.68 0.71 0.75]; % Quantum efficiency electron detector, for detecting at least one of one, two, three .... electrons.
d1.BR_fragment_pair.x_label	= 'Ci [-]'; % label on x-axis.
d1.BR_fragment_pair.y_label	= 'Branching ratio [$\#$ events]'; % label on y-axis.
d1.BR_fragment_pair.x_tick	= d1.BR_fragment_pair.C_nrs; % Tick on x-axis
d1.BR_fragment_pair.min_BR	= 1;% scalar, the minimum number of hits a channel must have to be approved.
d1.BR_fragment_pair.label_list = exp_md.conv.det1.m2q_labels;
d1.BR_fragment_pair.ifshow	= true;
d1.BR_fragment_pair.cond= exp_md.cond.angle_p_corr_C3;

% Plot style for Detector image plot:
d1.det_image.binsize       = [1 1]; %[mm] binsize of the m2q variable. 
d1.det_image.x_range		= [-40 40]; % [mm] x range of the data on x-axis.
d1.det_image.y_range		= [-40 40]; % [mm] y range of the data on y-axis.
d1.det_image.z_range		= [20]; % [Da] z range of the data on z-axis.
d1.det_image.x_label		= 'X [mm]'; % label on x-axis.
d1.det_image.y_label		= 'Y [mm]'; % label on y-axis.
d1.det_image.colormap		= 'jet'; % type of colormap
d1.det_image.axis          = 'equal'; % axis scaling
d1.det_image.colorbar		= 'yes'; % Do we want to see a colorbar
d1.det_image.cond				= exp_md.cond.label;

% Plotstyle for Radial position:
d1.R.binsize		= [0.2]; %[mm] binsize of the R variable. 
d1.R.x_range		= [0 40]; % [mm] y range of the data on y-axis.
d1.R.y_range		= 'Auto'; % [Counts] y range of the data.
d1.R.x_label		= 'R [mm]'; % label on y-axis.

% Plotstyle for Radial position:
d1.theta.binsize		= [0.2]; %[mm] binsize of the R variable. 
d1.theta.x_range		= [0 2*pi]; % [mm] y range of the data on y-axis.
d1.theta.y_range		= 'Auto'; % [Counts] y range of the data.
d1.theta.x_label		= '$\theta$ [rad]'; % label on y-axis.

% Plot style for TOF vs detector radius plot:
d1.TOF_R.binsize		= [5 0.2]; %[ns, mm] binsize of the m2q variable. 
d1.TOF_R.x_range		= [0 1.5e4]; % [ns] x range of the data on x-axis.
d1.TOF_R.y_range		= [0 40]; % [mm] y range of the data on y-axis.
d1.TOF_R.z_range		= [20]; % [Da] z range of the data on z-axis.
d1.TOF_R.x_label		= 'TOF [ns]'; % label on x-axis.
d1.TOF_R.y_label		= 'R [mm]'; % label on y-axis.
d1.TOF_R.colormap		= 'jet'; % type of colormap
d1.TOF_R.colorbar		= 'yes'; % Do we want to see a colorbar

% Plot style for 2D momentum histogram:
d1.p2D.binsize       	= [1, 1]*0.5e1; %[a.u.] binsize of the m2q variable. 
d1.p2D.x_range			= [-1 1]*1e2; % [a.u.] x range of the data on x-axis.
d1.p2D.y_range			= [-1 1]*1e2; % [a.u.] y range of the data on y-axis.
d1.p2D.z_range			= []; % [Da] z range of the data on z-axis.
d1.p2D.x_label			= '$p_x$ [a.u.]'; % label on x-axis.
d1.p2D.y_label			= '$p_z$ [a.u.]'; % label on y-axis.
d1.p2D.colormap			= 'jet'; % type of colormap
d1.p2D.colorbar			= 'no'; % Do we want to see a colorbar
d1.p2D.axis      		= 'equal'; % axis scaling
d1.p2D.cond				= exp_md.cond.label;

% Plot style for 3D momentum histogram:
d1.dp.binsize       	= [1, 1, 1]*1e1; %[a.u.] binsize of the m2q variable. 
d1.dp.x_range			= [-1 1]*1e2; % [a.u.] x range of the data on x-axis.
d1.dp.y_range			= [-1 1]*1e2; % [a.u.] y range of the data on y-axis.
d1.dp.z_range			= [-1 1]*1e2; % [a.u.] z range of the data on z-axis.
d1.dp.x_label			= '$p_x$ [a.u.]'; % label on x-axis.
d1.dp.y_label			= '$p_y$ [a.u.]'; % label on y-axis.
d1.dp.z_label			= '$p_z$ [a.u.]'; % label on z-axis.
d1.dp.contourvalue		= 0.22; % the number of hits in one bin that is shown as a contour.
d1.dp.axis      		= 'equal'; % axis scaling
d1.dp.lighting			= 'gouraud'; 
d1.dp.cond				= exp_md.cond.label;

% Plot style for KER histogram:
d1.KER.binsize       = 0.01; %[eV] binsize of the m2q variable. 
d1.KER.x_range		= [0 3]; % [eV] x range of the data on x-axis.
d1.KER.y_range		= 'Automatic'; % [a.u.] y range of the data on y-axis.
d1.KER.Intensity_type = 'Normalized'; %Show normalized intensity.
d1.KER.x_label		= 'KER [eV]'; % label on x-axis.
d1.KER.y_label		= 'Intensity [Counts]'; % label on y-axis.


% Plot style for KER sum histogram:
d1.KER_sum.binsize        = 0.4; %[eV] binsize of the m2q variable. 
d1.KER_sum.x_range		= [0 15]; % [eV] x range of the data on x-axis.
d1.KER_sum.y_range		= 'Automatic'; % [a.u.] y range of the data on y-axis.
d1.KER_sum.Intensity_type = 'Normalized'; %Show normalized intensity.
d1.KER_sum.x_label        = 'total ion KER [eV]'; % label on x-axis.
d1.KER_sum.y_label		= 'Intensity [Norm.]'; % label on y-axis.
d1.KER_sum.cond           =  exp_md.cond.BR;

% Plot style for mutual angles between momenta histogram (double coincidence):
d1.angle_p_corr_C2.plottype		= 'solid_angle_polar';
d1.angle_p_corr_C2.binsize		= pi/20; %[deg] binsize of the m2q variable. 
d1.angle_p_corr_C2.x_range		= [0.1 pi-0.01]; % [deg] x range of the data on x-axis.
d1.angle_p_corr_C2.y_range		= 'Normalized'; % [a.u.] y range of the data on y-axis.
d1.angle_p_corr_C2.thetaLim		= [0 180]; % The angular limits of the show polar plot.
d1.angle_p_corr_C2.rLim 		= [0 1]; % The radial limits of the show polar plot.
d1.angle_p_corr_C2.x_label		= 'mutual momentum angle [deg]'; % label on x-axis.
d1.angle_p_corr_C2.y_label		= 'Int. [norm]'; % label on y-axis.
d1.angle_p_corr_C2.color			= 'r'; % label on y-axis.
d1.angle_p_corr_C2.LineStyle		= '-'; % label on y-axis.
d1.angle_p_corr_C2.hist_factor		= 1;
d1.angle_p_corr_C2.cond			= exp_md.cond.angle_p_corr_C2;
d1.angle_p_corr_C2.cond			=  exp_md.cond.incompl;
d1.angle_p_corr_C2.pair_name		= 'NH$_3$ - (NH$_3$)$_n$H';

% Plot style for mutual angles between momenta histogram (triple coincidence):
d1.angle_p_corr_C3                = d1.angle_p_corr_C2;
d1.angle_p_corr_C3.binsize		= pi/30; %[deg] binsize of the m2q variable. 
d1.angle_p_corr_C3.x_range		= [0.1 pi-0.01]; % [deg] x range of the data on x-axis.
d1.angle_p_corr_C3.cond           = exp_md.cond.angle_p_corr_C3;
% d1.angle_p_corr_C3.cond			=  exp_md.cond.incompl;
d1.angle_p_corr_C3.combinations  	= [1 2; 2 3; 3 1]; % combinations of fragments to show
d1.angle_p_corr_C3.merge_combinations  	= true; % Whether or not to merge the combinations to one line

% Plot style for mutual angles between momenta histogram (quadruple coincidence):
d1.angle_p_corr_C4                = d1.angle_p_corr_C2;
d1.angle_p_corr_C4.cond           = exp_md.cond.angle_p_corr_C4;

% Plot style for mutual angles between momenta histogram (double coincidence):
d1.KER_angle_p_corr_C2.plottype		= 'solid_angle_polar_2D';
d1.KER_angle_p_corr_C2.PlotType		= 'surfcn';
d1.KER_angle_p_corr_C2.InterpMethod	= 'Nearest';
d1.KER_angle_p_corr_C2.binsize		= [0.08 0.08]; %[deg, eV] binsize of the m2q variable. 
d1.KER_angle_p_corr_C2.x_range		= [0.01 pi-0.001]; % [deg] x range of the data on x-axis.
d1.KER_angle_p_corr_C2.y_range		= [0 10]; % [eV] y (KER) range of the data on y-axis.
d1.KER_angle_p_corr_C2.thetaLim		= [0 180]; % The angular limits of the show polar plot.
d1.KER_angle_p_corr_C2.x_label		= 'mutual momentum angle [deg]'; % label on x-axis.
d1.KER_angle_p_corr_C2.y_label		= 'KER [eV]'; % label on y-axis.
d1.KER_angle_p_corr_C2.x_tick			= [0]; % label on y-axis.
d1.KER_angle_p_corr_C2.RadLabels		= 4;
d1.KER_angle_p_corr_C2.GridScale		= [100 100];
d1.KER_angle_p_corr_C2.cond			= exp_md.cond.angle_p_corr_C2;
d1.KER_angle_p_corr_C2.PolarGrid		= {0, 0};
d1.KER_angle_p_corr_C2.colormap		= 'custom'; % type of colormap
d1.KER_angle_p_corr_C2.colormap_r		= [1 1];
d1.KER_angle_p_corr_C2.colormap_g		= [1 0];
d1.KER_angle_p_corr_C2.colormap_b		= [1 0];
d1.KER_angle_p_corr_C2.axis      		= 'equal'; % axis scaling

% Plot style for mutual angles between momenta histogram (triple coincidence):
d1.KER_angle_p_corr_C3.plottype		= 'solid_angle_polar_2D';
d1.KER_angle_p_corr_C3.PlotType		= 'surfcn';
d1.KER_angle_p_corr_C3.InterpMethod	= 'Nearest';
d1.KER_angle_p_corr_C3.binsize		= [0.08 0.08]; %[deg, eV] binsize of the m2q variable. 
d1.KER_angle_p_corr_C3.x_range		= [0.01 pi-0.001]; % [deg] x range of the data on x-axis.
d1.KER_angle_p_corr_C3.y_range		= [0 10]; % [eV] y (KER) range of the data on y-axis.
d1.KER_angle_p_corr_C3.thetaLim		= [0 180]; % The angular limits of the show polar plot.
d1.KER_angle_p_corr_C3.x_label		= 'mutual momentum angle [deg]'; % label on x-axis.
d1.KER_angle_p_corr_C3.y_label		= 'KER [eV]'; % label on y-axis.
d1.KER_angle_p_corr_C3.x_tick			= [0]; % label on y-axis.
d1.KER_angle_p_corr_C3.RadLabels		= 4;
d1.KER_angle_p_corr_C3.GridScale		= [100 100];
d1.KER_angle_p_corr_C3.cond			= exp_md.cond.angle_p_corr_C3;
d1.KER_angle_p_corr_C3.PolarGrid		= {0, 0};
d1.KER_angle_p_corr_C3.colormap		= 'custom'; % type of colormap
d1.KER_angle_p_corr_C3.colormap_r		= [1 1];
d1.KER_angle_p_corr_C3.colormap_g		= [1 0];
d1.KER_angle_p_corr_C3.colormap_b		= [1 0];
d1.KER_angle_p_corr_C3.axis      		= 'equal'; % axis scaling

% Plot style for mutual angles between momenta histogram (double coincidence):
d1.p_norm_angle_corr_C2.plottype		= 'solid_angle_polar_2D';
d1.p_norm_angle_corr_C2.PlotType		= 'surfcn';
d1.p_norm_angle_corr_C2.InterpMethod	= 'Nearest';
d1.p_norm_angle_corr_C2.binsize			= [0.1 5]; %[deg, au] binsize of the variables. 
d1.p_norm_angle_corr_C2.x_range			= [0 pi]; % [deg] x range of the data on x-axis.
d1.p_norm_angle_corr_C2.y_range			= [0 150]; % [au] y (p_norm) range of the data on y-axis.
d1.p_norm_angle_corr_C2.thetaLim		= [0 180]; % The angular limits of the show polar plot.
d1.p_norm_angle_corr_C2.x_label			= '$|p_{sum}|$ [a.u.]'; % label on x-axis.
d1.p_norm_angle_corr_C2.x_tick			= [0:50:200]; % label on x-axis.
d1.p_norm_angle_corr_C2.y_tick			= []; % label on y-axis.
d1.p_norm_angle_corr_C2.RadLabels		= 4;
% d1.p_norm_angle_corr_C2.TickSpacing		= 0;
d1.p_norm_angle_corr_C2.GridScale		= [100 100];
d1.p_norm_angle_corr_C2.cond			= exp_md.cond.angle_p_corr_C2;
d1.p_norm_angle_corr_C2.PolarGrid		= {0, 0};
d1.p_norm_angle_corr_C2.colormap		= 'custom'; % type of colormap
d1.p_norm_angle_corr_C2.colormap_r		= [1 1];
d1.p_norm_angle_corr_C2.colormap_g		= [1 0];
d1.p_norm_angle_corr_C2.colormap_b		= [1 0];
d1.p_norm_angle_corr_C2.axis      		= 'equal'; % axis scaling

% Plot style for mutual angles between momenta histogram (double coincidence):
d1.p_norm_angle_corr_C3.plottype		= 'solid_angle_polar_2D';
d1.p_norm_angle_corr_C3.PlotType		= 'surfcn';
d1.p_norm_angle_corr_C3.InterpMethod	= 'Nearest';
d1.p_norm_angle_corr_C3.binsize			= [0.08 4]; %[rad, au] binsize of the variables. 
d1.p_norm_angle_corr_C3.x_range			= [0 pi]; % [rad] x range of the data on x-axis.
d1.p_norm_angle_corr_C3.y_range			= [0 200]; % [au] y (p_norm) range of the data on y-axis.
d1.p_norm_angle_corr_C3.thetaLim		= [0 180]; % The angular limits of the show polar plot.
d1.p_norm_angle_corr_C3.x_label			= ''; % label on x-axis.
d1.p_norm_angle_corr_C3.x_label			= '$|p_{sum}|$ [a.u.]'; % label on y-axis.
d1.p_norm_angle_corr_C3.y_tick			= []; % label on y-axis.
d1.p_norm_angle_corr_C3.x_tick			= [0:50:200]; % label on y-axis.
d1.p_norm_angle_corr_C3.RadLabels		= 4;
d1.p_norm_angle_corr_C3.GridScale		= [100 100];
% d1.p_norm_angle_corr_C3.AxisLocation	= 'bottom';
% d1.p_norm_angle_corr_C3.RadLabelLocation = {0 'bottom'};
d1.p_norm_angle_corr_C3.cond			= exp_md.cond.angle_p_corr_C3;
d1.p_norm_angle_corr_C3.PolarGrid		= {0, 0};
d1.p_norm_angle_corr_C3.colormap		= 'custom'; % type of colormap
d1.p_norm_angle_corr_C3.colormap_r		= [1 1];
d1.p_norm_angle_corr_C3.colormap_g		= [1 0];
d1.p_norm_angle_corr_C3.colormap_b		= [1 0];
d1.p_norm_angle_corr_C3.axis      		= 'equal'; % axis scaling

% Plot style for mutual angles between momenta histogram (double coincidence):
d1.norm_p_corr_C2.binsize			= 1e0*[1 1]; % binsize of the m2q variable. 
d1.norm_p_corr_C2.x_range			= [0 100]; % data range on x-axis.
d1.norm_p_corr_C2.y_range			= [0 100]; % data range on y-axis.
d1.norm_p_corr_C2.x_label			= '$|p_1|$'; % label on x-axis.
d1.norm_p_corr_C2.y_label			= '$|p_2|$'; % label on y-axis.
d1.norm_p_corr_C2.x_tick			= 0:10:100;
d1.norm_p_corr_C2.y_tick			= 0:10:100;
d1.norm_p_corr_C2.grid			= 'on';
d1.norm_p_corr_C2.cond			= exp_md.cond.angle_p_corr_C2;
d1.norm_p_corr_C2.colormap		= 'custom'; % type of colormap
d1.norm_p_corr_C2.colormap_r		= [1 1];
d1.norm_p_corr_C2.colormap_g		= [1 0];
d1.norm_p_corr_C2.colormap_b		= [1 0];
d1.norm_p_corr_C2.axis			= 'equal';
d1.norm_p_corr_C2.ifdo.reference_line = true; % whether to plot the line of complete detection.
d1.norm_p_corr_C2.reference_line.slope = 1;
d1.norm_p_corr_C2.reference_line.y0 = 0;
d1.norm_p_corr_C2.reference_line.x0 = 0;
d1.norm_p_corr_C2.reference_line.LineStyle = '-';
d1.norm_p_corr_C2.reference_line.LineWidth = 0.1;
d1.norm_p_corr_C2.reference_line.Color = 'k';
d1.norm_p_corr_C2.reference_line.Opacity = 1;

% Plot style for mutual angles between momenta histogram (triple coincidence):
d1.norm_p_corr_C3_ternary.plottype   = 'ternary';
d1.norm_p_corr_C3_ternary.binsize       = 1e-2*[1 1 1]; % binsize of the m2q variable. 
d1.norm_p_corr_C3_ternary.x_label		= '$|p_1|$'; % label on x-axis.
d1.norm_p_corr_C3_ternary.y_label		= '$|p_2|$'; % label on y-axis.
d1.norm_p_corr_C3_ternary.z_label		= '$|p_3|$'; % label on y-axis.
d1.norm_p_corr_C3_ternary.cond       = exp_md.cond.angle_p_corr_C3;
d1.norm_p_corr_C3_ternary.colormap		= 'custom'; % type of colormap
d1.norm_p_corr_C3_ternary.colormap_r		= [1 1];
d1.norm_p_corr_C3_ternary.colormap_g		= [1 0];
d1.norm_p_corr_C3_ternary.colormap_b		= [1 0];

% Plot style for mutual angles between momenta histogram (double coincidence):
d1.norm_p_corr_C2_ternary				= d1.norm_p_corr_C3_ternary;
d1.norm_p_corr_C2_ternary.cond       = exp_md.cond.angle_p_corr_C2;
d1.norm_p_corr_C2_ternary.z_label		= '$p_3 (virtual)$'; % label on y-axis.

% Plot style for 2D residual momentum histogram:
d1.p_sum_norm.binsize       	= 1*0.5e1; %[a.u.] binsize of the p_res variable. 
d1.p_sum_norm.x_range			= [0 400]*1e0; % [a.u.] x range of the data on x-axis.
d1.p_sum_norm.x_label			= '$norm(\vec{p}_{res}) = norm(\Sigma{\vec{p}_{i}})$ [a.u.]'; % label on x-axis.
d1.p_sum_norm.y_label			= 'Int. [norm]'; % label on y-axis.
d1.p_sum_norm.Intensity_type = 'Normalized'; %Show normalized intensity.
d1.p_sum_norm.cond			= exp_md.cond.angle_p_corr_C3;

% Plot style for 2D (X,Y)- source position calculation:
d1.source_position.binsize			= [1, 1]*1e0; %[a.u.] binsize of the x,y variables. 
d1.source_position.x_range			= [-1.05 1.05]*1e1; % [a.u.] x range of the data on x-axis.
d1.source_position.y_range			= [-1.05 1.05]*1e1; % [1e1.u.] y range of the data on y-axis.
d1.source_position.z_range			= 'auto'; %z range of the data on z-axis.
d1.source_position.x_label			= '$x$ [mm]'; % label on x-axis.
d1.source_position.y_label			= '$y$ [mm]'; % label on y-axis.
d1.source_position.axis      		= 'equal'; % axis scaling

% Plot style for cluster size histograms:
d1.cluster_size.binsize	= 1*1e0; %[Da] binsize of the cluster size variable. 
d1.cluster_size.x_range	= [-0.5 40.5]*1e0; %[Da] x-range of the data on x-axis.
d1.cluster_size.y_range	= 'Automatic'; % [arb.u.] y range of the data on y-axis.
d1.cluster_size.Intensity_type = 'Normalized'; % Show normalized intensity.
d1.cluster_size.x_label	= 'Recorded cluster size [\# molecules]'; % label on x-axis.
d1.cluster_size.y_label	= 'Int. [norm]'; % label on y-axis.

% Plot style for 1D Charge separation distance (CSD) histograms:
d1.CSD.binsize			= 1*1e0; %[Ångström] binsize of the CSD variable. 
d1.CSD.x_range			= [0 40]*1e0; %[Ångström] x-range of the data on x-axis.
d1.CSD.y_range			= 'Automatic'; % [arb.u.] y range of the data on y-axis.
d1.CSD.Intensity_type		= 'Normalized'; % Show normalized intensity.
d1.CSD.x_label			= 'CSD [\AA]'; % label on x-axis.
d1.CSD.y_label			= 'Int. [norm]'; % label on y-axis.
d1.CSD.cond				= exp_md.cond.angle_p_corr_C3;

% Plot style for 2D Charge separation distance (CSD) vs cluster size maps:
d1.CSD_cluster_size_sum.binsize			= [1,0.5]; %[Ångström, -] binsize of the CSD variable. 
d1.CSD_cluster_size_sum.x_range			= [-0.5 40.5]; %[] parent size.
d1.CSD_cluster_size_sum.y_range			= [0 40]*1e0; %[Ångström] x-range of the data on x-axis.
d1.CSD_cluster_size_sum.Intensity_type	= 'Normalized'; % Show normalized intensity.
d1.CSD_cluster_size_sum.x_label			= 'Recorded parent size [\# molecules]'; % label on x-axis.
d1.CSD_cluster_size_sum.y_label			= 'CSD [\AA]'; % label on y-axis.
d1.CSD_cluster_size_sum.colormap			= 'custom'; % type of colormap
d1.CSD_cluster_size_sum.colormap_r		= [1 1];
d1.CSD_cluster_size_sum.colormap_g		= [1 0];
d1.CSD_cluster_size_sum.colormap_b		= [1 0];
d1.CSD_cluster_size_sum.cond			= exp_md.cond.angle_p_corr_C3;


% Plot style for average Charge separation distance (CSD) vs cluster size maps:
d1.CSD_mean_cluster_size_sum.binsize			= d1.CSD_cluster_size_sum.binsize; %[Ångström, -] binsize of the CSD variable. 
d1.CSD_mean_cluster_size_sum.x_range			= d1.CSD_cluster_size_sum.x_range;
d1.CSD_mean_cluster_size_sum.y_range			= d1.CSD_cluster_size_sum.y_range;
d1.CSD_mean_cluster_size_sum.Intensity_type	= 'Normalized'; % Show normalized intensity.
d1.CSD_mean_cluster_size_sum.x_label			= 'Recorded parent size [\# molecules]'; % label on x-axis.
d1.CSD_mean_cluster_size_sum.y_label			= 'CSD [\AA]'; % label on y-axis.
d1.CSD_mean_cluster_size_sum.cond				= exp_md.cond.angle_p_corr_C2;
% d1.CSD_mean_cluster_size_sum.cond.C3			= macro.filter.write_coincidence_condition(3, 'det1');

d1.CSD_mean_m2q_l_sum.binsize			= [1, 0.5]; %[Da, Ångström] binsize of the CSD variable. 
d1.CSD_mean_m2q_l_sum.x_range			= [32 500];
d1.CSD_mean_m2q_l_sum.y_range			= [0, 60];
d1.CSD_mean_m2q_l_sum.Intensity_type	= 'Normalized'; % Show normalized intensity.
d1.CSD_mean_m2q_l_sum.x_label			= 'Recorded mass [Da]'; % label on x-axis.
d1.CSD_mean_m2q_l_sum.y_label			= 'CSD [\AA]'; % label on y-axis.
d1.CSD_mean_m2q_l_sum.color				= 'k';
d1.CSD_mean_m2q_l_sum.cond				= exp_md.cond.angle_p_corr_C3;

% Plot style for average Charge separation distance (CSD) vs cluster size maps:
d1.KER_sum_mean_m2q_l_sum.binsize			= [1, 0.05]; %[-, eV] binsize of the CSD variable. 
d1.KER_sum_mean_m2q_l_sum.x_range			= [25 500];
d1.KER_sum_mean_m2q_l_sum.y_range			= [0 10];
d1.KER_sum_mean_m2q_l_sum.Intensity_type	= 'Normalized'; % Show normalized intensity.
d1.KER_sum_mean_m2q_l_sum.x_label			= 'Recorded mass [Da]'; % label on x-axis.
d1.KER_sum_mean_m2q_l_sum.y_label			= 'KER [eV]'; % label on y-axis.
d1.KER_sum_mean_m2q_l_sum.color				= 'k';
d1.KER_sum_mean_m2q_l_sum.plottype			= '2D_y_1D';
d1.KER_sum_mean_m2q_l_sum.cond				= exp_md.cond.angle_p_corr_C2;
% d1.KER_sum_mean_m2q_l_sum.cond				= exp_md.cond.BR;

% Plot style for 1D fragment asymmetry histograms:
d1.fragment_asymmetry.binsize			= 1*2e-3; %[-] binsize of the CSD variable. 
d1.fragment_asymmetry.x_range			= [0 1]*1e0; %[Da] x-range of the data on x-axis.
d1.fragment_asymmetry.y_range			= 'Automatic'; % [arb.u.] y range of the data on y-axis.
d1.fragment_asymmetry.Intensity_type	= 'Normalized'; % Show normalized intensity.
d1.fragment_asymmetry.x_label			= 'fragment asymmetry [-]'; % label on x-axis.
d1.fragment_asymmetry.y_label			= 'Int. [norm]'; % label on y-axis.
d1.fragment_asymmetry.cond				= exp_md.cond.angle_p_corr_C2;

% Plot style for cluster size vs 1D fragment asymmetry histograms:
d1.cluster_size_sum_fragment_asymmetry.binsize			= [1, 1*1e-2]; %[-] binsize of the CSD variable. 
d1.cluster_size_sum_fragment_asymmetry.x_range			= d1.CSD_cluster_size_sum.x_range; %[-] parent size.
d1.cluster_size_sum_fragment_asymmetry.y_range			= d1.fragment_asymmetry.x_range; %[-] y range of the data on y-axis.
d1.cluster_size_sum_fragment_asymmetry.Intensity_type	= 'Normalized'; % Show normalized intensity.
d1.cluster_size_sum_fragment_asymmetry.x_label			= 'Recorded parent size [\# molecules]'; % label on x-axis
d1.cluster_size_sum_fragment_asymmetry.y_label			= 'fragment asymmetry [-]';% label on y-axis.
d1.cluster_size_sum_fragment_asymmetry.colormap			= 'custom'; % type of colormap
d1.cluster_size_sum_fragment_asymmetry.colormap_r		= [1 1];
d1.cluster_size_sum_fragment_asymmetry.colormap_g		= [1 0];
d1.cluster_size_sum_fragment_asymmetry.colormap_b		= [1 0];
d1.cluster_size_sum_fragment_asymmetry.color			= 'k';
d1.cluster_size_sum_fragment_asymmetry.cond				= exp_md.cond.angle_p_corr_C3;

exp_md.plot.det1 = d1;
end