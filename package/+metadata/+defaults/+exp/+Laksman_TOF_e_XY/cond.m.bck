function [exp_md] = cond(exp_md)
% This convenience function lists the default conditions metadata, and can be
% read by other experiment-specific metadata files.

% We define a few conditions, that can be used later in filtering
% operations:

%% Condition defaults
% Some commonly used ones, to refer to later:
% Events:
% Filter the total KER:
def.KER_sum.type             = 'continuous';
def.KER_sum.data_pointer     = 'e.det1.KER_sum';
def.KER_sum.value            = [2.4; 3];
def.KER_sum.value            = [0; 80];

% Hits:
% Filter the 'oil peaks' out:
def.oil.type                   = 'discrete';
def.oil.data_pointer           = 'h.det1.m2q_l';
def.oil.value                  = [72; 73];
def.oil.translate_condition    = 'AND';
def.oil.invert_filter          = true;

% Make sure we are looking at a cluster:
def.cluster_size_total.type             = 'discrete';
def.cluster_size_total.data_pointer     = ['h.det1.cluster_size_total'];
def.cluster_size_total.value            = [1:20];
def.cluster_size_total.translate_condition = 'AND'; % all hits must be clusters

% Get rid of large momenta:
def.p_sum.type             = 'continuous';
def.p_sum.data_pointer     = 'e.det1.p_sum_norm';
def.p_sum.value            = [0 ; 110];
def.p_sum.translate_condition = 'AND';
def.p_sum.invert_filter     = false;

% make sure one only takes the labeled hits:
def.label.type             = 'continuous';
def.label.data_pointer     = 'h.det1.m2q_l';
def.label.value            = [min(exp_md.conv.det1.m2q_labels); max(exp_md.conv.det1.m2q_labels)];
def.label.translate_condition = 'AND';

%% Conditions
%% Conditions: Labeled hits only

% % Make sure we are looking at labeled hits:
c.label.labeled_hits        = def.label;

if isfield(exp_md.sample, 'mass')
	c.label.total_masses.type			= 'continuous';
	c.label.total_masses.data_pointer	= 'e.det1.m2q_l_sum';
	c.label.total_masses.value		= [0; exp_md.sample.mass];
end

% c.label.labeled_hits2        = def.label;
% c.label.labeled_hits2.value  = [min(exp_md.conv.det1.m2q_labels(exp_md.conv.det1.m2q_labels > 50)); ...
% 								max(exp_md.conv.det1.m2q_labels)];
% c.label.labeled_hits2.translate_condition = 'OR';

c.label.KER_sum			= def.KER_sum;
c.label.KER_sum.value	= [0; 80];
%% Conditions: Clusters only

% % Make sure we are looking at a cluster for every hit:
c.cluster.hit_cluster_size_total        = def.cluster_size_total;
c.cluster.hit_cluster_size_total.value  = [1:40];
% Make sure we are looking at a cluster:
% c.cluster.event_cluster_size_total.type		= 'discrete';
% c.cluster.event_cluster_size_total.data_pointer	= 'e.det1.cluster_size_total';
% c.cluster.event_cluster_size_total.value		= [1:20];
c.cluster.oil							= def.oil;

%% Conditions: monomer fragments only

if isfield(exp_md.sample, 'monomer')
	monomer = exp_md.sample.monomer;
	c.monomer.fragment_masses.type			= 'discrete';
	c.monomer.fragment_masses.data_pointer	= 'h.det1.m2q_l';
	c.monomer.fragment_masses.value		= general.fragment_masses(monomer.fragment.masses, monomer.fragment.nof);
	c.monomer.fragment_masses.translate_condition = 'AND';
	
	c.monomer.total_masses.type			= 'continuous';
	c.monomer.total_masses.data_pointer	= 'e.det1.m2q_l_sum';
	c.monomer.total_masses.value		= [0; monomer.mass];
end

%% Conditions: Size distribution:
% % Events:
% Get only the triple coincidences:
% c.size_distribution.C3          = macro.filter.write_coincidence_condition(3, 'det1');

% Make sure we are looking at a cluster:
% Hits:
% pick the cluster:
c.size_distribution.hit_cluster_size_total = def.cluster_size_total;

% Filter the 'oil peaks' out:
c.size_distribution.oil                 = def.oil;

%% Conditions: BR

% Make a branching ratio filter, for the Ci branching ratio's:
c.BR.label1.type             = 'discrete';
c.BR.label1.data_pointer     = 'h.det1.m2q_l';
c.BR.label1.value            = [17]';
c.BR.label1.translate_condition = 'OR';

c.BR.label2					= c.BR.label1;
c.BR.label2.value           = [16]';

% Define normalization conditions:
% c.BR_normalize.label1				= c.BR.label1;
% c.BR_normalize.label1.value			= [17]';
% 
% c.BR_normalize.label2				= c.BR.label1;
% c.BR_normalize.label2.value         = [35]';
c.BR_normalize.cluster				= def.cluster_size_total;
%% Conditions: Momentum angle correlations (double coincidence):
% Events:

% Make sure we are looking at a cluster:
c.angle_p_corr_C2.n1.hit_cluster_size_total        = def.cluster_size_total;
c.angle_p_corr_C2.n1.hit_cluster_size_total.value  = [1:40];

% Hits:
% Filter the 'oil peaks' out:
c.angle_p_corr_C2.n1.oil                   = def.oil;

% Look at the small fragments:
c.angle_p_corr_C2.n2.small_fragm						= def.label;
c.angle_p_corr_C2.n2.small_fragm.type					= 'discrete';
c.angle_p_corr_C2.n2.small_fragm.value					= [16; 17; 18];
c.angle_p_corr_C2.n2.small_fragm.translate_condition	= 'AND';

c.angle_p_corr_C2.n2.symm_pairs.type			= 'discrete';
c.angle_p_corr_C2.n2.symm_pairs.data_pointer	= 'e.det1.fragment_asymmetry';
c.angle_p_corr_C2.n2.symm_pairs.value			= 0;
c.angle_p_corr_C2.n2.symm_pairs.invert_filter	= true; 

% Filter out only double coincidence:
c.angle_p_corr_C2.n3.C2				= macro.filter.write_coincidence_condition(2, 'det1');

% Filter the total KER, such that noise goes out:
c.angle_p_corr_C2.n3.KER_sum				= def.KER_sum;
c.angle_p_corr_C2.n3.KER_sum.value			= [0.1; 60]; 

c.angle_p_corr_C2.n3.p_sum                 = def.p_sum;
c.angle_p_corr_C2.n3.p_sum.value			= [0; 40];

c.angle_p_corr_C2.operators					= {'OR', 'AND'};

%% Conditions: Momentum angle correlations (triple coincidence):

% % Fetch the particle m2qs of interest:
% c.angle_p_corr_C3.n1.p1.type             = 'discrete';
% c.angle_p_corr_C3.n1.p1.data_pointer     = 'h.det1.m2q_l';
% c.angle_p_corr_C3.n1.p1.translate_condition = 'AND';
% c.angle_p_corr_C3.n1.p1.value			= [17; 18; 35; 52; 69; 86];
% c.angle_p_corr_C3.n1.p2					= c.angle_p_corr_C3.n1.p1;
% c.angle_p_corr_C3.n1.p2.translate_condition = 'OR';
% c.angle_p_corr_C3.n1.p2.value			= [18];

c.angle_p_corr_C3.n1.p1.type             = 'discrete';
c.angle_p_corr_C3.n1.p1.data_pointer     = 'h.det1.cluster_size_total';
c.angle_p_corr_C3.n1.p1.translate_condition = 'AND';
c.angle_p_corr_C3.n1.p1.value            = [1:40];

% Look at the small fragments:
c.angle_p_corr_C3.n2.small_fragm						= def.label;
c.angle_p_corr_C3.n2.small_fragm.type					= 'discrete';
c.angle_p_corr_C3.n2.small_fragm.value					= [16; 17; 18];
c.angle_p_corr_C3.n2.small_fragm.translate_condition	= 'AND';

c.angle_p_corr_C3.n2.symm_pairs.type			= 'discrete';
c.angle_p_corr_C3.n2.symm_pairs.data_pointer	= 'e.det1.fragment_asymmetry';
c.angle_p_corr_C3.n2.symm_pairs.value			= 0;
c.angle_p_corr_C3.n2.symm_pairs.invert_filter	= true; 

% Events:	
% Get only the triple coincidences:
c.angle_p_corr_C3.n3.C3                  = macro.filter.write_coincidence_condition(3, 'det1');

% Filter the total KER, such that noise goes out:
c.angle_p_corr_C3.n3.KER_sum             = def.KER_sum;
c.angle_p_corr_C3.n3.KER_sum.value			= [0; 80]; 

% % Make sure we are looking at a cluster:
% c.angle_p_corr_C3.hit_cluster_size_total        = def.cluster_size_total;
% c.angle_p_corr_C3.hit_cluster_size_total.value  = [1:40];

% Hits:
% Filter the 'oil peaks' out:
c.angle_p_corr_C3.n3.oil                   = def.oil;
 
% Get rid of large momenta:
c.angle_p_corr_C3.n3.p_sum                 = def.p_sum;
c.angle_p_corr_C3.n3.p_sum.value			= [0; 200];


c.angle_p_corr_C3.operators					= {'OR' 'AND'};

%% Conditions: Momentum angle correlations (quadruple coincidence):
c.angle_p_corr_C4.C4                        = macro.filter.write_coincidence_condition(4, 'det1');
c.angle_p_corr_C4.hit_cluster_size_total    = def.cluster_size_total;

c.angle_p_corr_C4.KER_sum                   = def.KER_sum;
c.angle_p_corr_C4.KER_sum.value             = [0; 4];

%% Conditions: Momentum norm correlation (triple coincidence):
% % Events:
c.norm_p_corr_C3.C3                         = macro.filter.write_coincidence_condition(3, 'det1');

% Filter the total KER:
c.norm_p_corr_C3.KER_sum              = def.KER_sum;
c.norm_p_corr_C3.KER_sum.value        = [0; 80];

% Make sure we are looking at a cluster:
c.norm_p_corr_C3.hit_cluster_size_total     = def.cluster_size_total;

% Specify the parent size we want to see:
c.norm_p_corr_C3.event_cluster_size_total.type             = 'discrete';
c.norm_p_corr_C3.event_cluster_size_total.data_pointer     = ['e.det1.cluster_size_total'];
c.norm_p_corr_C3.event_cluster_size_total.value            = [0:100];

% Hits:
% Filter the 'oil peaks' out:
c.norm_p_corr_C3.oil                   = def.oil;

%% Conditions: Momentum norm correlation (double coincidence):
c.norm_p_corr_C2				= c.norm_p_corr_C3;
c.norm_p_corr_C2				= rmfield(c.norm_p_corr_C3, 'C3');
c.norm_p_corr_C2.C2				= macro.filter.write_coincidence_condition(2, 'det1');

%% Conditions: Charge Separation Distance (single coincidence):
% % Events:
% % Get only the double coincidences:
% c.CSD_C1.C1                  = macro.filter.write_coincidence_condition(1, 'det1');
% % Filter the total KER, such that noise goes out:
% c.CSD_C1.KER_sum             = def.KER_sum;
% c.CSD_C1.KER_sum.value			= [0; 80]; 
% % Make sure we are looking at a cluster:
% c.CSD_C1.hit_cluster_size_total        = def.cluster_size_total;
% c.CSD_C1.hit_cluster_size_total.value  = [1:40];
% % Hits:
% % Filter the 'oil peaks' out:
% c.CSD_C1.oil                   = def.oil;
% 
% %% Conditions: Charge Separation Distance (double coincidence):
% % Events:
% % Get only the double coincidences:
% c.CSD_C2.C2                  = macro.filter.write_coincidence_condition(2, 'det1');
% % Filter the total KER, such that noise goes out:
% c.CSD_C2.KER_sum             = def.KER_sum;
% c.CSD_C2.KER_sum.value			= [0; 80]; 
% % Make sure we are looking at a cluster:
% c.CSD_C2.hit_cluster_size_total        = def.cluster_size_total;
% c.CSD_C2.hit_cluster_size_total.value  = [1:40];
% % Hits:
% % Filter the 'oil peaks' out:
% c.CSD_C2.oil                   = def.oil;
% % Get rid of large momenta:
% c.CSD_C2.p_sum                 = def.p_sum;
% c.CSD_C2.p_sum.value			= [0; 50];
% 
% % c.CSD_C2.back2back_pair.type             = 'discrete';
% % c.CSD_C2.back2back_pair.data_pointer     = 'h.det1.m2q_l';
% % c.CSD_C2.back2back_pair.value            = [(1:3)*17+1]';
% % c.CSD_C2.back2back_pair.translate_condition = 'OR';
% 
% % c.CSD_C2.unprot_monomer.type             = 'discrete';
% % c.CSD_C2.unprot_monomer.data_pointer     = 'h.det1.m2q_l';
% % c.CSD_C2.unprot_monomer.value            = 17;
% % c.CSD_C2.unprot_monomer.translate_condition = 'AND';

%% Conditions: Charge Separation Distance (triple coincidence):
% % Events:	
% % Get only the triple coincidences:
% c.CSD_C3.C3                  = macro.filter.write_coincidence_condition(3, 'det1');
% % Filter the total KER, such that noise goes out:
% c.CSD_C3.KER_sum             = def.KER_sum;
% c.CSD_C3.KER_sum.value			= [0; 80]; 
% % Make sure we are looking at a cluster:
% c.CSD_C3.hit_cluster_size_total        = def.cluster_size_total;
% c.CSD_C3.hit_cluster_size_total.value  = [1:40];
% % Hits:
% % Filter the 'oil peaks' out:
% c.CSD_C3.oil                   = def.oil;

%% Conditions: Charge Separation Distance (triple coincidence):
% % Events:	
% % Get only the triple coincidences:
% c.CSD_small_fragments.C2                  = macro.filter.write_coincidence_condition(2, 'det1');
% % Filter the total KER, such that noise goes out:
% c.CSD_small_fragments.KER_sum             = def.KER_sum;
% c.CSD_small_fragments.KER_sum.value		  = [0; 80]; 
% % Hits:
% % Filter the 'oil peaks' out:
% c.CSD_small_fragments.oil                   = def.oil;
% % Get rid of large momenta:
% c.CSD_small_fragments.p_sum                 = def.p_sum;
% c.CSD_small_fragments.p_sum.value			= [0; 50];
% 
% c.CSD_small_fragments.label	= def.label;
% c.CSD_small_fragments.label.value			= [16; 18];

%%
exp_md.cond = c;
end