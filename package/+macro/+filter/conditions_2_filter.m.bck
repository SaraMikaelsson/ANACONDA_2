function [f] = conditions_2_filter( exp_data, conditions )
% [event_filter] = conditions_2_filter(exp_data, conditions)
% This general event filtering function returns an event filter that follows
% all user-specified conditions.
%	Example:
% conditions is a struct with the fields with their condition names:
% conditions.labeled_hits
% This field contains information on this condition:
% conditions.labeled_hits.type			type of condition. can be
%										'discrete' or 'continuous'
% conditions.labeled_hits.data_pointer	which data the condition should apply to
%										For example: 'h.det1.m2q_l' to
%										apply to the mass-to-charge labels
% conditions.labeled_hits.value			The value the conditions apply to.
%										If conditions.labeled_hits.type is
%										'discrete', the data should exactly
%										equal this value. 
%										If conditions.labeled_hits.type is
%										'continuous', two values should be
%										given, interpreted as min and max.
% conditions.labeled_hits.translate_condition Only relevant for hit
%										conditions: the constructed hit filter
%										will be translated to an event
%										filter, and if all hits in an event
%										must be approved, 'AND' must be
%										given for this field. If only one of all hits
%										should be approved for the event to
%										be approved, 'OR' should be given.
% conditions.labeled_hits.invert_filter (optional) logical: if 'true', the
%										event filter will be inverted 
%										(true becomes false, false becomes true)
events          = exp_data.e.raw;
f				= true(size(events,1),1);
is_meta_condition = false;
try is_meta_condition = ~isfield(conditions, 'data_pointer') & isstruct (conditions) & ~isempty(conditions); end

if  is_meta_condition
	% The user has defined multiple sets of operators, so they are considered
	% separately and afterwards combined:
	fn_w_op = fieldnames(conditions);
	fn		= fn_w_op(~strcmp(fn_w_op, 'operators'));
	if ~isfield(conditions, 'operators') % If the operators are not defined, we assume 'AND':
		conditions.operators = repmat({'AND'}, 1, length(fn)-1);
	end
	f_e_all = zeros(size(events,1), length(fn));
	f = macro.filter.conditions_2_filter(exp_data, conditions.(fn{1}));
	for i = 2:length(fn)
		switch conditions.operators{i-1}
			case 'OR'
				f = f | macro.filter.conditions_2_filter(exp_data, conditions.(fn{i}));
			case 'AND'
				f = f & macro.filter.conditions_2_filter(exp_data, conditions.(fn{i}));
		end
	end
	
elseif ~isempty(conditions)

	condition_name = fieldnames(conditions);
	
	% Read the data pointer
		condition_data = eval(['exp_data.' conditions.data_pointer]);
	% And read the value of the actual condition:
	condition_value = conditions.value;
	% In case the value is depending on another variable, we send it out:
	switch general.struct.probe_field(conditions, 'value_type')
		case 'var' % variable value type
			condition.(condition_name) =  conditions;
			f = macro.filter.var_conditions_2_filter(exp_data, condition);
		otherwise
		% Check whether the conditions are discrete or continuous:
		switch conditions.type
			case 'discrete' % A discrete condition. Write the filter:
				f = filter.hits.labeled_hits(condition_data, condition_value);
			case 'continuous'
				f = filter.hits.range(condition_data, condition_value(1,:), condition_value(2,:));
		end
		% Check whether the filter should be inverted:
		if general.struct.probe_field(conditions, 'invert_filter')
			f = ~f;
		end
		% We have calculated the filter from the given conditions.
		% Check whether the conditions are event or hit properties:
		switch conditions.data_pointer(1)
			case 'e'% Events. We can directly merge them with the event filter
				f_e					= f;
			case 'h'% Hits. We have to translate the filter to an event filter
				translate_condition = conditions.translate_condition;
				nof_hits            = size(f,1);
				detnr               = IO.det_nr_from_fieldname(conditions.data_pointer);
				f                   = filter.hits_2_events(f, events(:,detnr), nof_hits, translate_condition);
		end
	end
end

end